# 典型的调度算法



## 先来先服务（FCFS）算法

- FCFS调度算法是一种最简单的调度算法，它既可作用于作业调度，又可作用于进程调度
- 不会导致饥饿
- 非抢占式的算法

### 算法思想

- 在作业调度中，FCFS调度算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列
- 在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将CPU分配给它，使之投之运行，直到运行完成或因某种原因而阻塞时才释放CPU

### 例题

- 假设系统中有4个作业，它们的提交时间分别是8，8.4，8.8，9，运行时间依次是2，1，0.5，0.2，系统采用FCFS调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间

| 作业号 | 提交时间 | 运行时间 | 开始时间 | 等待时间 | 完成时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | -------- | -------- | -------- | -------- | -------- | ------------ |
| 1      | 8        | 2        | 8        | 0        | 10       | 2        | 1            |
| 2      | 8.4      | 1        | 10       | 1.6      | 11       | 2.6      | 2.6          |
| 3      | 8.8      | 0.5      | 11       | 2.2      | 11.5     | 2.7      | 5.4          |
| 4      | 9        | 0.2      | 11.5     | 2.5      | 11.7     | 2.7      | 13.5         |

| 时间                                                    |
| ------------------------------------------------------- |
| 平均等待时间 t = (0 + 1.6 + 2.2 + 2.5) / 4 = 1.575      |
| 平均周转时间 T = (2 + 2.6 + 2.7 + 2.7) / 4 = 2.5        |
| 平均带权周转时间 W = (1 + 2.6 + 5.4 + 13.5) / 4 = 5.625 |

### FCFS算法优劣

- FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如：在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按照FCFS原则处理
- FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于 I / O繁忙型作业





## 短作业优先（SJF）调度算法

- 进程调度
- 短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先（SJF）调度算法从后备队列中选择一个或几个估计运行时间最短的进程，将它们调入内存运行；短进程优先（SPF）调度算法从就绪队列中选择一个估计运行时间最短的进程，将CPU分配给它，使之立即执行，直到完成或发生某事件而阻塞时才释放CPU

### 例题

| 作业号 | 提交时间 | 运行时间 | 开始时间 | 等待时间 | 完成时间 | 周转时间 | 带权周转时间 |
| ------ | -------- | -------- | -------- | -------- | -------- | -------- | ------------ |
| 1      | 8        | 2        | 8        | 0        | 10       | 2        | 1            |
| 2      | 8.4      | 1        | 10.7     | 2.3      | 11.7     | 3.3      | 3.3          |
| 3      | 8.8      | 0.5      | 10.2     | 1.4      | 10.7     | 1.9      | 3.8          |
| 4      | 9        | 0.2      | 10       | 1        | 10.2     | 1.2      | 6            |

| 时间                                                 |
| ---------------------------------------------------- |
| 平均等待时间 t = (0 + 2.3 + 1.4 + 1) / 4 = 1.175     |
| 平均周转时间 T = (2 + 3.3 + 1.9 + 1.2) / 4 = 2.1     |
| 平均带权周转时间 W = (1 + 3.3 + 3.8 + 6) / 4 = 3.525 |

### SJF调度算法的缺点

- 该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。更严重的是，若有一长作业进入系统的后备队列，由于调度程序总是优先调度那些（即使是后来进来的）短作业，将导致长作业长期不被调度，产生“饥饿现象”，如果一直得不到服务，则称为“饿死”
- 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被即使处理
- 由于作业的长短是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度

> 短作业（SJF）调度算法的平均等待时间、平均周转时间是“最优”的
>
> 并不是真正“最优的”，只有在所有进程都几乎同时到达时才是最优的





## 最短剩余时间优先算法（SPF）

- 抢占式的短作业优先算法又称最短剩余时间优先算法（SPF）
- 每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度

### 例题

| 进程 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| p1   | 0        | 7        |
| p2   | 2        | 4        |
| p3   | 4        | 1        |
| P4   | 5        | 4        |

| 运行顺序                                     |
| -------------------------------------------- |
| 0时刻（p1到达）：p1(7)                       |
| 2时刻（p2到达）：p1(5)、p2(4)                |
| 4时刻（p3到达）：p1(5)、p2(2)、p3(1)         |
| 5时刻（p3完成且p4到达）：p1(5)、p2(2)、p4(4) |
| 7时刻（p2完成）：p1(5)、p4(4)                |
| 11时刻（p4完成）：p1(5)、                    |





## 高响应比优先调度算法

- 高响应比优先调度算法主要用于作业调度，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选取响应比最高的作业投入运行

- $$ 响应比R~p~ = \frac{等待时间 + 要求服务时间}{要求服务时间} $$

- 作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业，因而类似于SJF

- 要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而类似于FCFS

- 对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，也可获得CPU，克服“饥饿”现象

- 不会导致饥饿

- 抢占式

  

  



## 优先级调度算法

- 优先级调度算法既可用于作业调度，又可用于进程调度。该算法中的优先级用于描述作业的紧迫程度。在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将CPU分配给它，使之投入运行

### 非抢占式优先级调度算法

- 当一个进程正在CPU上运行时，即使有某个优先级更高的进程进入就绪队列，仍让正在运行的进程继续运行，直到由于其自身的原因而让出CPU时（任务完成或等待事件），才将CPU分配给就绪队列中优先级最高的进程

### 抢占式优先级调度算法

- 当一个进程正在CPU上运行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在运行的进程，将CPU分配给优先级更高的进城进而根据地进程创建后其优先级是否改变，可将进程优先级分为以下两种
  - 静态优先级
    - 优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先级的主要依据有进程类型、进程对资源的要求、用户要求。优点是简单易行，系统开销小；缺点是不够精确，可能出现优先级低的进程长期得不到调度的情况

  - 动态优先级
    - 创建进程时先赋予进程一个优先级，但优先级会随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。例如，规定优先级随等待时间的增加而提高，于是，对于优先级初值较低的进程，等待足够长的时间后也可获得CPU
    - 优先级设置参考一下原则
      - 系统进程  > 用户进程
        - 系统进程作为系统的管理者，理应拥有更高的优先级

      - 交互性进程 > 非交互性进程（或前台进程  > 后台进程）
      - I/O型 进程 > 计算型进程
        - 所谓I/O型进程，是指那些会频繁使用I/O设备的进程，而计算型进程是那些频繁使用CPU的进程（很少使用I/O设备）
        - I/O设备（如打印机）的处理速度要比CPU慢得多，因此若将I/O型进程的优先级设置得更高，就更有可能让I/O设备今早开始工作，进而提高系统的整体效率






## 时间片轮转（RR）调度算法

- 抢占式进程切换
- 不会产生饥饿现象
- 公平地轮流地为各个进程服务让每个进程在一定时间间隔内可以响应

- 主要适用于分时系统。在这种算法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设置每隔一定的时间（如30ms）便产生一次时钟中断，激活调度程序进行调度，将CPU分配给就绪队列的队首进程，并令其执行一个时间片。在执行完一个时间片后，即使进程并未运行完成，它也必须释放出（被剥夺）CPU给就绪队列的新队首进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行
- 在RR算法中，若一个时间片尚未用完而当前进程已运行完成，则调度程序会被立即激活；若一个时间片用完，则产生一个时钟中断，由时钟中断处理程序来激活程序调度程序

> 一般来说，设计时间片时要让切换进程开销占比不超过1%

### 特点

- 在RR调度算法中，时间片的大小对系统性能的影响很大。若时间片足够大以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。若时间片很小，则CPU将在进程间过于频繁地切换，使CPU的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当，时间片的长短通常有以下因素确定
  - 系统的响应时间、就绪队列中的进程数目和系统处理能力





## 多级队列调度算法

- 前述的各种调度算法，由于系统中仅设置一个进程的就绪队列，即调度算法是固定且单一的，无法满足系统中不同用户对进程调度策略的不同要求。在多CPU系统中，这种单一调度策略实现机制的缺点更为突出，多级队列调度算法能在一定程度上弥补这一缺点
- 该算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列。每个队列可实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。同一队列中的进程可以设置不同的优先级，不同的队列本身也可以设置不同的优先级。在多CPU系统中，可以很方便为每个CPU设置一个单独的就绪队列，每个CPU可实施各自不同的调度策略，这样就能根据用户需求将多个线程分配到一个或多个CPU上运行





## 多级反馈队列调度算法

- 多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展，通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间
- 产生饥饿，抢占式



### 算法思想

- 设置多个就绪队列，并为每个队列赋予不同的优先级。第1级队列的优先级最高，第2优先级队列的优先级次之，其余队列的优先级逐个降低
- 赋予各个队列的进程运行时间片的大小各不相同。在优先级越高的队列中，每个进程的时间片就越小。例如，第$i + 1$级队列的时间片要比第$i$级队列的时间片长1倍
- 每个队列都采用FCFS算法。新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。若它在一个时间片结束时尚未完成，调度程序将其转入第2级队列的末尾等待调度；若它在第2级队列中运行一个时间片后仍未完成，再将它放入第3级队列，以此类推。当程序最后被降到第n级队列后，在第n级队列中便采用时间片轮转方式运行
- 按队列优先级调度。仅当第1级队列为空时，才调度第2级队列中的进程运行；仅当第$1～i - 1$级队列均为空时，才会调度第$i$级队列中的进程运行。若CPU正在执行第$i$级队列中的某个进程时，又有新进程进入任何一个优先级较高的队列，此时须立即将正在运行的进程放回到第$i$级队列的末尾，而将CPU分配给新到的高优先级进程



### 优势

- 终端型作业用户：短作业优先
- 短批处理作业用户：周转时间较短
- 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理
